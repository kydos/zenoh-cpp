// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cloudevents.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cloudevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cloudevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cloudevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cloudevents_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cloudevents_2eproto;
namespace io {
namespace cloudevents {
namespace v1 {
class CloudEvent;
struct CloudEventDefaultTypeInternal;
extern CloudEventDefaultTypeInternal _CloudEvent_default_instance_;
class CloudEventBatch;
struct CloudEventBatchDefaultTypeInternal;
extern CloudEventBatchDefaultTypeInternal _CloudEventBatch_default_instance_;
class CloudEvent_AttributesEntry_DoNotUse;
struct CloudEvent_AttributesEntry_DoNotUseDefaultTypeInternal;
extern CloudEvent_AttributesEntry_DoNotUseDefaultTypeInternal _CloudEvent_AttributesEntry_DoNotUse_default_instance_;
class CloudEvent_CloudEventAttributeValue;
struct CloudEvent_CloudEventAttributeValueDefaultTypeInternal;
extern CloudEvent_CloudEventAttributeValueDefaultTypeInternal _CloudEvent_CloudEventAttributeValue_default_instance_;
}  // namespace v1
}  // namespace cloudevents
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::cloudevents::v1::CloudEvent* Arena::CreateMaybeMessage<::io::cloudevents::v1::CloudEvent>(Arena*);
template<> ::io::cloudevents::v1::CloudEventBatch* Arena::CreateMaybeMessage<::io::cloudevents::v1::CloudEventBatch>(Arena*);
template<> ::io::cloudevents::v1::CloudEvent_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::io::cloudevents::v1::CloudEvent_AttributesEntry_DoNotUse>(Arena*);
template<> ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue* Arena::CreateMaybeMessage<::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace cloudevents {
namespace v1 {

// ===================================================================

class CloudEvent_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CloudEvent_AttributesEntry_DoNotUse, 
    std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CloudEvent_AttributesEntry_DoNotUse, 
    std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CloudEvent_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CloudEvent_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CloudEvent_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CloudEvent_AttributesEntry_DoNotUse& other);
  static const CloudEvent_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CloudEvent_AttributesEntry_DoNotUse*>(&_CloudEvent_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "io.cloudevents.v1.CloudEvent.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_cloudevents_2eproto;
};

// -------------------------------------------------------------------

class CloudEvent_CloudEventAttributeValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue) */ {
 public:
  inline CloudEvent_CloudEventAttributeValue() : CloudEvent_CloudEventAttributeValue(nullptr) {}
  ~CloudEvent_CloudEventAttributeValue() override;
  explicit PROTOBUF_CONSTEXPR CloudEvent_CloudEventAttributeValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloudEvent_CloudEventAttributeValue(const CloudEvent_CloudEventAttributeValue& from);
  CloudEvent_CloudEventAttributeValue(CloudEvent_CloudEventAttributeValue&& from) noexcept
    : CloudEvent_CloudEventAttributeValue() {
    *this = ::std::move(from);
  }

  inline CloudEvent_CloudEventAttributeValue& operator=(const CloudEvent_CloudEventAttributeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudEvent_CloudEventAttributeValue& operator=(CloudEvent_CloudEventAttributeValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudEvent_CloudEventAttributeValue& default_instance() {
    return *internal_default_instance();
  }
  enum AttrCase {
    kCeBoolean = 1,
    kCeInteger = 2,
    kCeString = 3,
    kCeBytes = 4,
    kCeUri = 5,
    kCeUriRef = 6,
    kCeTimestamp = 7,
    ATTR_NOT_SET = 0,
  };

  static inline const CloudEvent_CloudEventAttributeValue* internal_default_instance() {
    return reinterpret_cast<const CloudEvent_CloudEventAttributeValue*>(
               &_CloudEvent_CloudEventAttributeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CloudEvent_CloudEventAttributeValue& a, CloudEvent_CloudEventAttributeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudEvent_CloudEventAttributeValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudEvent_CloudEventAttributeValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudEvent_CloudEventAttributeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloudEvent_CloudEventAttributeValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloudEvent_CloudEventAttributeValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloudEvent_CloudEventAttributeValue& from) {
    CloudEvent_CloudEventAttributeValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudEvent_CloudEventAttributeValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.cloudevents.v1.CloudEvent.CloudEventAttributeValue";
  }
  protected:
  explicit CloudEvent_CloudEventAttributeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCeBooleanFieldNumber = 1,
    kCeIntegerFieldNumber = 2,
    kCeStringFieldNumber = 3,
    kCeBytesFieldNumber = 4,
    kCeUriFieldNumber = 5,
    kCeUriRefFieldNumber = 6,
    kCeTimestampFieldNumber = 7,
  };
  // bool ce_boolean = 1;
  bool has_ce_boolean() const;
  private:
  bool _internal_has_ce_boolean() const;
  public:
  void clear_ce_boolean();
  bool ce_boolean() const;
  void set_ce_boolean(bool value);
  private:
  bool _internal_ce_boolean() const;
  void _internal_set_ce_boolean(bool value);
  public:

  // int32 ce_integer = 2;
  bool has_ce_integer() const;
  private:
  bool _internal_has_ce_integer() const;
  public:
  void clear_ce_integer();
  int32_t ce_integer() const;
  void set_ce_integer(int32_t value);
  private:
  int32_t _internal_ce_integer() const;
  void _internal_set_ce_integer(int32_t value);
  public:

  // string ce_string = 3;
  bool has_ce_string() const;
  private:
  bool _internal_has_ce_string() const;
  public:
  void clear_ce_string();
  const std::string& ce_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ce_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ce_string();
  PROTOBUF_NODISCARD std::string* release_ce_string();
  void set_allocated_ce_string(std::string* ce_string);
  private:
  const std::string& _internal_ce_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ce_string(const std::string& value);
  std::string* _internal_mutable_ce_string();
  public:

  // bytes ce_bytes = 4;
  bool has_ce_bytes() const;
  private:
  bool _internal_has_ce_bytes() const;
  public:
  void clear_ce_bytes();
  const std::string& ce_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ce_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ce_bytes();
  PROTOBUF_NODISCARD std::string* release_ce_bytes();
  void set_allocated_ce_bytes(std::string* ce_bytes);
  private:
  const std::string& _internal_ce_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ce_bytes(const std::string& value);
  std::string* _internal_mutable_ce_bytes();
  public:

  // string ce_uri = 5;
  bool has_ce_uri() const;
  private:
  bool _internal_has_ce_uri() const;
  public:
  void clear_ce_uri();
  const std::string& ce_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ce_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ce_uri();
  PROTOBUF_NODISCARD std::string* release_ce_uri();
  void set_allocated_ce_uri(std::string* ce_uri);
  private:
  const std::string& _internal_ce_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ce_uri(const std::string& value);
  std::string* _internal_mutable_ce_uri();
  public:

  // string ce_uri_ref = 6;
  bool has_ce_uri_ref() const;
  private:
  bool _internal_has_ce_uri_ref() const;
  public:
  void clear_ce_uri_ref();
  const std::string& ce_uri_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ce_uri_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ce_uri_ref();
  PROTOBUF_NODISCARD std::string* release_ce_uri_ref();
  void set_allocated_ce_uri_ref(std::string* ce_uri_ref);
  private:
  const std::string& _internal_ce_uri_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ce_uri_ref(const std::string& value);
  std::string* _internal_mutable_ce_uri_ref();
  public:

  // .google.protobuf.Timestamp ce_timestamp = 7;
  bool has_ce_timestamp() const;
  private:
  bool _internal_has_ce_timestamp() const;
  public:
  void clear_ce_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& ce_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_ce_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_ce_timestamp();
  void set_allocated_ce_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* ce_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_ce_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_ce_timestamp();
  public:
  void unsafe_arena_set_allocated_ce_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* ce_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_ce_timestamp();

  void clear_attr();
  AttrCase attr_case() const;
  // @@protoc_insertion_point(class_scope:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue)
 private:
  class _Internal;
  void set_has_ce_boolean();
  void set_has_ce_integer();
  void set_has_ce_string();
  void set_has_ce_bytes();
  void set_has_ce_uri();
  void set_has_ce_uri_ref();
  void set_has_ce_timestamp();

  inline bool has_attr() const;
  inline void clear_has_attr();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union AttrUnion {
      constexpr AttrUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool ce_boolean_;
      int32_t ce_integer_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ce_string_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ce_bytes_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ce_uri_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ce_uri_ref_;
      ::PROTOBUF_NAMESPACE_ID::Timestamp* ce_timestamp_;
    } attr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudevents_2eproto;
};
// -------------------------------------------------------------------

class CloudEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.cloudevents.v1.CloudEvent) */ {
 public:
  inline CloudEvent() : CloudEvent(nullptr) {}
  ~CloudEvent() override;
  explicit PROTOBUF_CONSTEXPR CloudEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloudEvent(const CloudEvent& from);
  CloudEvent(CloudEvent&& from) noexcept
    : CloudEvent() {
    *this = ::std::move(from);
  }

  inline CloudEvent& operator=(const CloudEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudEvent& operator=(CloudEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudEvent& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kBinaryData = 6,
    kTextData = 7,
    kProtoData = 8,
    DATA_NOT_SET = 0,
  };

  static inline const CloudEvent* internal_default_instance() {
    return reinterpret_cast<const CloudEvent*>(
               &_CloudEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CloudEvent& a, CloudEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloudEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloudEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloudEvent& from) {
    CloudEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.cloudevents.v1.CloudEvent";
  }
  protected:
  explicit CloudEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CloudEvent_CloudEventAttributeValue CloudEventAttributeValue;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kIdFieldNumber = 1,
    kSourceFieldNumber = 2,
    kSpecVersionFieldNumber = 3,
    kTypeFieldNumber = 4,
    kBinaryDataFieldNumber = 6,
    kTextDataFieldNumber = 7,
    kProtoDataFieldNumber = 8,
  };
  // map<string, .io.cloudevents.v1.CloudEvent.CloudEventAttributeValue> attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >*
      mutable_attributes();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string source = 2;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string spec_version = 3;
  void clear_spec_version();
  const std::string& spec_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spec_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spec_version();
  PROTOBUF_NODISCARD std::string* release_spec_version();
  void set_allocated_spec_version(std::string* spec_version);
  private:
  const std::string& _internal_spec_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spec_version(const std::string& value);
  std::string* _internal_mutable_spec_version();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes binary_data = 6;
  bool has_binary_data() const;
  private:
  bool _internal_has_binary_data() const;
  public:
  void clear_binary_data();
  const std::string& binary_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_data();
  PROTOBUF_NODISCARD std::string* release_binary_data();
  void set_allocated_binary_data(std::string* binary_data);
  private:
  const std::string& _internal_binary_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_data(const std::string& value);
  std::string* _internal_mutable_binary_data();
  public:

  // string text_data = 7;
  bool has_text_data() const;
  private:
  bool _internal_has_text_data() const;
  public:
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // .google.protobuf.Any proto_data = 8;
  bool has_proto_data() const;
  private:
  bool _internal_has_proto_data() const;
  public:
  void clear_proto_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& proto_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_proto_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_proto_data();
  void set_allocated_proto_data(::PROTOBUF_NAMESPACE_ID::Any* proto_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_proto_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_proto_data();
  public:
  void unsafe_arena_set_allocated_proto_data(
      ::PROTOBUF_NAMESPACE_ID::Any* proto_data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_proto_data();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.cloudevents.v1.CloudEvent)
 private:
  class _Internal;
  void set_has_binary_data();
  void set_has_text_data();
  void set_has_proto_data();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CloudEvent_AttributesEntry_DoNotUse,
        std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spec_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_data_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
      ::PROTOBUF_NAMESPACE_ID::Any* proto_data_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudevents_2eproto;
};
// -------------------------------------------------------------------

class CloudEventBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.cloudevents.v1.CloudEventBatch) */ {
 public:
  inline CloudEventBatch() : CloudEventBatch(nullptr) {}
  ~CloudEventBatch() override;
  explicit PROTOBUF_CONSTEXPR CloudEventBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloudEventBatch(const CloudEventBatch& from);
  CloudEventBatch(CloudEventBatch&& from) noexcept
    : CloudEventBatch() {
    *this = ::std::move(from);
  }

  inline CloudEventBatch& operator=(const CloudEventBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloudEventBatch& operator=(CloudEventBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloudEventBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloudEventBatch* internal_default_instance() {
    return reinterpret_cast<const CloudEventBatch*>(
               &_CloudEventBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CloudEventBatch& a, CloudEventBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(CloudEventBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloudEventBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloudEventBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloudEventBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloudEventBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloudEventBatch& from) {
    CloudEventBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudEventBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.cloudevents.v1.CloudEventBatch";
  }
  protected:
  explicit CloudEventBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .io.cloudevents.v1.CloudEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::io::cloudevents::v1::CloudEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::cloudevents::v1::CloudEvent >*
      mutable_events();
  private:
  const ::io::cloudevents::v1::CloudEvent& _internal_events(int index) const;
  ::io::cloudevents::v1::CloudEvent* _internal_add_events();
  public:
  const ::io::cloudevents::v1::CloudEvent& events(int index) const;
  ::io::cloudevents::v1::CloudEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::cloudevents::v1::CloudEvent >&
      events() const;

  // @@protoc_insertion_point(class_scope:io.cloudevents.v1.CloudEventBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::cloudevents::v1::CloudEvent > events_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cloudevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CloudEvent_CloudEventAttributeValue

// bool ce_boolean = 1;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_boolean() const {
  return attr_case() == kCeBoolean;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_boolean() const {
  return _internal_has_ce_boolean();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_boolean() {
  _impl_._oneof_case_[0] = kCeBoolean;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_boolean() {
  if (_internal_has_ce_boolean()) {
    _impl_.attr_.ce_boolean_ = false;
    clear_has_attr();
  }
}
inline bool CloudEvent_CloudEventAttributeValue::_internal_ce_boolean() const {
  if (_internal_has_ce_boolean()) {
    return _impl_.attr_.ce_boolean_;
  }
  return false;
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_boolean(bool value) {
  if (!_internal_has_ce_boolean()) {
    clear_attr();
    set_has_ce_boolean();
  }
  _impl_.attr_.ce_boolean_ = value;
}
inline bool CloudEvent_CloudEventAttributeValue::ce_boolean() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_boolean)
  return _internal_ce_boolean();
}
inline void CloudEvent_CloudEventAttributeValue::set_ce_boolean(bool value) {
  _internal_set_ce_boolean(value);
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_boolean)
}

// int32 ce_integer = 2;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_integer() const {
  return attr_case() == kCeInteger;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_integer() const {
  return _internal_has_ce_integer();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_integer() {
  _impl_._oneof_case_[0] = kCeInteger;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_integer() {
  if (_internal_has_ce_integer()) {
    _impl_.attr_.ce_integer_ = 0;
    clear_has_attr();
  }
}
inline int32_t CloudEvent_CloudEventAttributeValue::_internal_ce_integer() const {
  if (_internal_has_ce_integer()) {
    return _impl_.attr_.ce_integer_;
  }
  return 0;
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_integer(int32_t value) {
  if (!_internal_has_ce_integer()) {
    clear_attr();
    set_has_ce_integer();
  }
  _impl_.attr_.ce_integer_ = value;
}
inline int32_t CloudEvent_CloudEventAttributeValue::ce_integer() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_integer)
  return _internal_ce_integer();
}
inline void CloudEvent_CloudEventAttributeValue::set_ce_integer(int32_t value) {
  _internal_set_ce_integer(value);
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_integer)
}

// string ce_string = 3;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_string() const {
  return attr_case() == kCeString;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_string() const {
  return _internal_has_ce_string();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_string() {
  _impl_._oneof_case_[0] = kCeString;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_string() {
  if (_internal_has_ce_string()) {
    _impl_.attr_.ce_string_.Destroy();
    clear_has_attr();
  }
}
inline const std::string& CloudEvent_CloudEventAttributeValue::ce_string() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_string)
  return _internal_ce_string();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent_CloudEventAttributeValue::set_ce_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ce_string()) {
    clear_attr();
    set_has_ce_string();
    _impl_.attr_.ce_string_.InitDefault();
  }
  _impl_.attr_.ce_string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_string)
}
inline std::string* CloudEvent_CloudEventAttributeValue::mutable_ce_string() {
  std::string* _s = _internal_mutable_ce_string();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_string)
  return _s;
}
inline const std::string& CloudEvent_CloudEventAttributeValue::_internal_ce_string() const {
  if (_internal_has_ce_string()) {
    return _impl_.attr_.ce_string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_string(const std::string& value) {
  if (!_internal_has_ce_string()) {
    clear_attr();
    set_has_ce_string();
    _impl_.attr_.ce_string_.InitDefault();
  }
  _impl_.attr_.ce_string_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::_internal_mutable_ce_string() {
  if (!_internal_has_ce_string()) {
    clear_attr();
    set_has_ce_string();
    _impl_.attr_.ce_string_.InitDefault();
  }
  return _impl_.attr_.ce_string_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::release_ce_string() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_string)
  if (_internal_has_ce_string()) {
    clear_has_attr();
    return _impl_.attr_.ce_string_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent_CloudEventAttributeValue::set_allocated_ce_string(std::string* ce_string) {
  if (has_attr()) {
    clear_attr();
  }
  if (ce_string != nullptr) {
    set_has_ce_string();
    _impl_.attr_.ce_string_.InitAllocated(ce_string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_string)
}

// bytes ce_bytes = 4;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_bytes() const {
  return attr_case() == kCeBytes;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_bytes() const {
  return _internal_has_ce_bytes();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_bytes() {
  _impl_._oneof_case_[0] = kCeBytes;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_bytes() {
  if (_internal_has_ce_bytes()) {
    _impl_.attr_.ce_bytes_.Destroy();
    clear_has_attr();
  }
}
inline const std::string& CloudEvent_CloudEventAttributeValue::ce_bytes() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_bytes)
  return _internal_ce_bytes();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent_CloudEventAttributeValue::set_ce_bytes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ce_bytes()) {
    clear_attr();
    set_has_ce_bytes();
    _impl_.attr_.ce_bytes_.InitDefault();
  }
  _impl_.attr_.ce_bytes_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_bytes)
}
inline std::string* CloudEvent_CloudEventAttributeValue::mutable_ce_bytes() {
  std::string* _s = _internal_mutable_ce_bytes();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_bytes)
  return _s;
}
inline const std::string& CloudEvent_CloudEventAttributeValue::_internal_ce_bytes() const {
  if (_internal_has_ce_bytes()) {
    return _impl_.attr_.ce_bytes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_bytes(const std::string& value) {
  if (!_internal_has_ce_bytes()) {
    clear_attr();
    set_has_ce_bytes();
    _impl_.attr_.ce_bytes_.InitDefault();
  }
  _impl_.attr_.ce_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::_internal_mutable_ce_bytes() {
  if (!_internal_has_ce_bytes()) {
    clear_attr();
    set_has_ce_bytes();
    _impl_.attr_.ce_bytes_.InitDefault();
  }
  return _impl_.attr_.ce_bytes_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::release_ce_bytes() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_bytes)
  if (_internal_has_ce_bytes()) {
    clear_has_attr();
    return _impl_.attr_.ce_bytes_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent_CloudEventAttributeValue::set_allocated_ce_bytes(std::string* ce_bytes) {
  if (has_attr()) {
    clear_attr();
  }
  if (ce_bytes != nullptr) {
    set_has_ce_bytes();
    _impl_.attr_.ce_bytes_.InitAllocated(ce_bytes, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_bytes)
}

// string ce_uri = 5;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_uri() const {
  return attr_case() == kCeUri;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_uri() const {
  return _internal_has_ce_uri();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_uri() {
  _impl_._oneof_case_[0] = kCeUri;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_uri() {
  if (_internal_has_ce_uri()) {
    _impl_.attr_.ce_uri_.Destroy();
    clear_has_attr();
  }
}
inline const std::string& CloudEvent_CloudEventAttributeValue::ce_uri() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri)
  return _internal_ce_uri();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent_CloudEventAttributeValue::set_ce_uri(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ce_uri()) {
    clear_attr();
    set_has_ce_uri();
    _impl_.attr_.ce_uri_.InitDefault();
  }
  _impl_.attr_.ce_uri_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri)
}
inline std::string* CloudEvent_CloudEventAttributeValue::mutable_ce_uri() {
  std::string* _s = _internal_mutable_ce_uri();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri)
  return _s;
}
inline const std::string& CloudEvent_CloudEventAttributeValue::_internal_ce_uri() const {
  if (_internal_has_ce_uri()) {
    return _impl_.attr_.ce_uri_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_uri(const std::string& value) {
  if (!_internal_has_ce_uri()) {
    clear_attr();
    set_has_ce_uri();
    _impl_.attr_.ce_uri_.InitDefault();
  }
  _impl_.attr_.ce_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::_internal_mutable_ce_uri() {
  if (!_internal_has_ce_uri()) {
    clear_attr();
    set_has_ce_uri();
    _impl_.attr_.ce_uri_.InitDefault();
  }
  return _impl_.attr_.ce_uri_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::release_ce_uri() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri)
  if (_internal_has_ce_uri()) {
    clear_has_attr();
    return _impl_.attr_.ce_uri_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent_CloudEventAttributeValue::set_allocated_ce_uri(std::string* ce_uri) {
  if (has_attr()) {
    clear_attr();
  }
  if (ce_uri != nullptr) {
    set_has_ce_uri();
    _impl_.attr_.ce_uri_.InitAllocated(ce_uri, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri)
}

// string ce_uri_ref = 6;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_uri_ref() const {
  return attr_case() == kCeUriRef;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_uri_ref() const {
  return _internal_has_ce_uri_ref();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_uri_ref() {
  _impl_._oneof_case_[0] = kCeUriRef;
}
inline void CloudEvent_CloudEventAttributeValue::clear_ce_uri_ref() {
  if (_internal_has_ce_uri_ref()) {
    _impl_.attr_.ce_uri_ref_.Destroy();
    clear_has_attr();
  }
}
inline const std::string& CloudEvent_CloudEventAttributeValue::ce_uri_ref() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref)
  return _internal_ce_uri_ref();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent_CloudEventAttributeValue::set_ce_uri_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_ce_uri_ref()) {
    clear_attr();
    set_has_ce_uri_ref();
    _impl_.attr_.ce_uri_ref_.InitDefault();
  }
  _impl_.attr_.ce_uri_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref)
}
inline std::string* CloudEvent_CloudEventAttributeValue::mutable_ce_uri_ref() {
  std::string* _s = _internal_mutable_ce_uri_ref();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref)
  return _s;
}
inline const std::string& CloudEvent_CloudEventAttributeValue::_internal_ce_uri_ref() const {
  if (_internal_has_ce_uri_ref()) {
    return _impl_.attr_.ce_uri_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent_CloudEventAttributeValue::_internal_set_ce_uri_ref(const std::string& value) {
  if (!_internal_has_ce_uri_ref()) {
    clear_attr();
    set_has_ce_uri_ref();
    _impl_.attr_.ce_uri_ref_.InitDefault();
  }
  _impl_.attr_.ce_uri_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::_internal_mutable_ce_uri_ref() {
  if (!_internal_has_ce_uri_ref()) {
    clear_attr();
    set_has_ce_uri_ref();
    _impl_.attr_.ce_uri_ref_.InitDefault();
  }
  return _impl_.attr_.ce_uri_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent_CloudEventAttributeValue::release_ce_uri_ref() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref)
  if (_internal_has_ce_uri_ref()) {
    clear_has_attr();
    return _impl_.attr_.ce_uri_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent_CloudEventAttributeValue::set_allocated_ce_uri_ref(std::string* ce_uri_ref) {
  if (has_attr()) {
    clear_attr();
  }
  if (ce_uri_ref != nullptr) {
    set_has_ce_uri_ref();
    _impl_.attr_.ce_uri_ref_.InitAllocated(ce_uri_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_uri_ref)
}

// .google.protobuf.Timestamp ce_timestamp = 7;
inline bool CloudEvent_CloudEventAttributeValue::_internal_has_ce_timestamp() const {
  return attr_case() == kCeTimestamp;
}
inline bool CloudEvent_CloudEventAttributeValue::has_ce_timestamp() const {
  return _internal_has_ce_timestamp();
}
inline void CloudEvent_CloudEventAttributeValue::set_has_ce_timestamp() {
  _impl_._oneof_case_[0] = kCeTimestamp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CloudEvent_CloudEventAttributeValue::release_ce_timestamp() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp)
  if (_internal_has_ce_timestamp()) {
    clear_has_attr();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.attr_.ce_timestamp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.attr_.ce_timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CloudEvent_CloudEventAttributeValue::_internal_ce_timestamp() const {
  return _internal_has_ce_timestamp()
      ? *_impl_.attr_.ce_timestamp_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Timestamp&>(::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& CloudEvent_CloudEventAttributeValue::ce_timestamp() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp)
  return _internal_ce_timestamp();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CloudEvent_CloudEventAttributeValue::unsafe_arena_release_ce_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp)
  if (_internal_has_ce_timestamp()) {
    clear_has_attr();
    ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.attr_.ce_timestamp_;
    _impl_.attr_.ce_timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CloudEvent_CloudEventAttributeValue::unsafe_arena_set_allocated_ce_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* ce_timestamp) {
  clear_attr();
  if (ce_timestamp) {
    set_has_ce_timestamp();
    _impl_.attr_.ce_timestamp_ = ce_timestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CloudEvent_CloudEventAttributeValue::_internal_mutable_ce_timestamp() {
  if (!_internal_has_ce_timestamp()) {
    clear_attr();
    set_has_ce_timestamp();
    _impl_.attr_.ce_timestamp_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.attr_.ce_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* CloudEvent_CloudEventAttributeValue::mutable_ce_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_ce_timestamp();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.ce_timestamp)
  return _msg;
}

inline bool CloudEvent_CloudEventAttributeValue::has_attr() const {
  return attr_case() != ATTR_NOT_SET;
}
inline void CloudEvent_CloudEventAttributeValue::clear_has_attr() {
  _impl_._oneof_case_[0] = ATTR_NOT_SET;
}
inline CloudEvent_CloudEventAttributeValue::AttrCase CloudEvent_CloudEventAttributeValue::attr_case() const {
  return CloudEvent_CloudEventAttributeValue::AttrCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CloudEvent

// string id = 1;
inline void CloudEvent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CloudEvent::id() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudEvent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.id)
}
inline std::string* CloudEvent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.id)
  return _s;
}
inline const std::string& CloudEvent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CloudEvent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudEvent::release_id() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.id)
  return _impl_.id_.Release();
}
inline void CloudEvent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.id)
}

// string source = 2;
inline void CloudEvent::clear_source() {
  _impl_.source_.ClearToEmpty();
}
inline const std::string& CloudEvent::source() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudEvent::set_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.source)
}
inline std::string* CloudEvent::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.source)
  return _s;
}
inline const std::string& CloudEvent::_internal_source() const {
  return _impl_.source_.Get();
}
inline void CloudEvent::_internal_set_source(const std::string& value) {
  
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_source() {
  
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudEvent::release_source() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.source)
  return _impl_.source_.Release();
}
inline void CloudEvent::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.source)
}

// string spec_version = 3;
inline void CloudEvent::clear_spec_version() {
  _impl_.spec_version_.ClearToEmpty();
}
inline const std::string& CloudEvent::spec_version() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.spec_version)
  return _internal_spec_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudEvent::set_spec_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spec_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.spec_version)
}
inline std::string* CloudEvent::mutable_spec_version() {
  std::string* _s = _internal_mutable_spec_version();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.spec_version)
  return _s;
}
inline const std::string& CloudEvent::_internal_spec_version() const {
  return _impl_.spec_version_.Get();
}
inline void CloudEvent::_internal_set_spec_version(const std::string& value) {
  
  _impl_.spec_version_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_spec_version() {
  
  return _impl_.spec_version_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudEvent::release_spec_version() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.spec_version)
  return _impl_.spec_version_.Release();
}
inline void CloudEvent::set_allocated_spec_version(std::string* spec_version) {
  if (spec_version != nullptr) {
    
  } else {
    
  }
  _impl_.spec_version_.SetAllocated(spec_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spec_version_.IsDefault()) {
    _impl_.spec_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.spec_version)
}

// string type = 4;
inline void CloudEvent::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& CloudEvent::type() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloudEvent::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.type)
}
inline std::string* CloudEvent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.type)
  return _s;
}
inline const std::string& CloudEvent::_internal_type() const {
  return _impl_.type_.Get();
}
inline void CloudEvent::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* CloudEvent::release_type() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.type)
  return _impl_.type_.Release();
}
inline void CloudEvent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.type)
}

// map<string, .io.cloudevents.v1.CloudEvent.CloudEventAttributeValue> attributes = 5;
inline int CloudEvent::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int CloudEvent::attributes_size() const {
  return _internal_attributes_size();
}
inline void CloudEvent::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >&
CloudEvent::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >&
CloudEvent::attributes() const {
  // @@protoc_insertion_point(field_map:io.cloudevents.v1.CloudEvent.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >*
CloudEvent::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::io::cloudevents::v1::CloudEvent_CloudEventAttributeValue >*
CloudEvent::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:io.cloudevents.v1.CloudEvent.attributes)
  return _internal_mutable_attributes();
}

// bytes binary_data = 6;
inline bool CloudEvent::_internal_has_binary_data() const {
  return data_case() == kBinaryData;
}
inline bool CloudEvent::has_binary_data() const {
  return _internal_has_binary_data();
}
inline void CloudEvent::set_has_binary_data() {
  _impl_._oneof_case_[0] = kBinaryData;
}
inline void CloudEvent::clear_binary_data() {
  if (_internal_has_binary_data()) {
    _impl_.data_.binary_data_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CloudEvent::binary_data() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.binary_data)
  return _internal_binary_data();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent::set_binary_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary_data()) {
    clear_data();
    set_has_binary_data();
    _impl_.data_.binary_data_.InitDefault();
  }
  _impl_.data_.binary_data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.binary_data)
}
inline std::string* CloudEvent::mutable_binary_data() {
  std::string* _s = _internal_mutable_binary_data();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.binary_data)
  return _s;
}
inline const std::string& CloudEvent::_internal_binary_data() const {
  if (_internal_has_binary_data()) {
    return _impl_.data_.binary_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent::_internal_set_binary_data(const std::string& value) {
  if (!_internal_has_binary_data()) {
    clear_data();
    set_has_binary_data();
    _impl_.data_.binary_data_.InitDefault();
  }
  _impl_.data_.binary_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_binary_data() {
  if (!_internal_has_binary_data()) {
    clear_data();
    set_has_binary_data();
    _impl_.data_.binary_data_.InitDefault();
  }
  return _impl_.data_.binary_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent::release_binary_data() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.binary_data)
  if (_internal_has_binary_data()) {
    clear_has_data();
    return _impl_.data_.binary_data_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent::set_allocated_binary_data(std::string* binary_data) {
  if (has_data()) {
    clear_data();
  }
  if (binary_data != nullptr) {
    set_has_binary_data();
    _impl_.data_.binary_data_.InitAllocated(binary_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.binary_data)
}

// string text_data = 7;
inline bool CloudEvent::_internal_has_text_data() const {
  return data_case() == kTextData;
}
inline bool CloudEvent::has_text_data() const {
  return _internal_has_text_data();
}
inline void CloudEvent::set_has_text_data() {
  _impl_._oneof_case_[0] = kTextData;
}
inline void CloudEvent::clear_text_data() {
  if (_internal_has_text_data()) {
    _impl_.data_.text_data_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CloudEvent::text_data() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline void CloudEvent::set_text_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text_data()) {
    clear_data();
    set_has_text_data();
    _impl_.data_.text_data_.InitDefault();
  }
  _impl_.data_.text_data_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.cloudevents.v1.CloudEvent.text_data)
}
inline std::string* CloudEvent::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.text_data)
  return _s;
}
inline const std::string& CloudEvent::_internal_text_data() const {
  if (_internal_has_text_data()) {
    return _impl_.data_.text_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CloudEvent::_internal_set_text_data(const std::string& value) {
  if (!_internal_has_text_data()) {
    clear_data();
    set_has_text_data();
    _impl_.data_.text_data_.InitDefault();
  }
  _impl_.data_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CloudEvent::_internal_mutable_text_data() {
  if (!_internal_has_text_data()) {
    clear_data();
    set_has_text_data();
    _impl_.data_.text_data_.InitDefault();
  }
  return _impl_.data_.text_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* CloudEvent::release_text_data() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.text_data)
  if (_internal_has_text_data()) {
    clear_has_data();
    return _impl_.data_.text_data_.Release();
  } else {
    return nullptr;
  }
}
inline void CloudEvent::set_allocated_text_data(std::string* text_data) {
  if (has_data()) {
    clear_data();
  }
  if (text_data != nullptr) {
    set_has_text_data();
    _impl_.data_.text_data_.InitAllocated(text_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.cloudevents.v1.CloudEvent.text_data)
}

// .google.protobuf.Any proto_data = 8;
inline bool CloudEvent::_internal_has_proto_data() const {
  return data_case() == kProtoData;
}
inline bool CloudEvent::has_proto_data() const {
  return _internal_has_proto_data();
}
inline void CloudEvent::set_has_proto_data() {
  _impl_._oneof_case_[0] = kProtoData;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CloudEvent::release_proto_data() {
  // @@protoc_insertion_point(field_release:io.cloudevents.v1.CloudEvent.proto_data)
  if (_internal_has_proto_data()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.data_.proto_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.proto_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CloudEvent::_internal_proto_data() const {
  return _internal_has_proto_data()
      ? *_impl_.data_.proto_data_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Any&>(::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& CloudEvent::proto_data() const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEvent.proto_data)
  return _internal_proto_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CloudEvent::unsafe_arena_release_proto_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.cloudevents.v1.CloudEvent.proto_data)
  if (_internal_has_proto_data()) {
    clear_has_data();
    ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.data_.proto_data_;
    _impl_.data_.proto_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CloudEvent::unsafe_arena_set_allocated_proto_data(::PROTOBUF_NAMESPACE_ID::Any* proto_data) {
  clear_data();
  if (proto_data) {
    set_has_proto_data();
    _impl_.data_.proto_data_ = proto_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.cloudevents.v1.CloudEvent.proto_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CloudEvent::_internal_mutable_proto_data() {
  if (!_internal_has_proto_data()) {
    clear_data();
    set_has_proto_data();
    _impl_.data_.proto_data_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Any >(GetArenaForAllocation());
  }
  return _impl_.data_.proto_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* CloudEvent::mutable_proto_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_proto_data();
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEvent.proto_data)
  return _msg;
}

inline bool CloudEvent::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void CloudEvent::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline CloudEvent::DataCase CloudEvent::data_case() const {
  return CloudEvent::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CloudEventBatch

// repeated .io.cloudevents.v1.CloudEvent events = 1;
inline int CloudEventBatch::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int CloudEventBatch::events_size() const {
  return _internal_events_size();
}
inline void CloudEventBatch::clear_events() {
  _impl_.events_.Clear();
}
inline ::io::cloudevents::v1::CloudEvent* CloudEventBatch::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:io.cloudevents.v1.CloudEventBatch.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::cloudevents::v1::CloudEvent >*
CloudEventBatch::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:io.cloudevents.v1.CloudEventBatch.events)
  return &_impl_.events_;
}
inline const ::io::cloudevents::v1::CloudEvent& CloudEventBatch::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::io::cloudevents::v1::CloudEvent& CloudEventBatch::events(int index) const {
  // @@protoc_insertion_point(field_get:io.cloudevents.v1.CloudEventBatch.events)
  return _internal_events(index);
}
inline ::io::cloudevents::v1::CloudEvent* CloudEventBatch::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::io::cloudevents::v1::CloudEvent* CloudEventBatch::add_events() {
  ::io::cloudevents::v1::CloudEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:io.cloudevents.v1.CloudEventBatch.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::cloudevents::v1::CloudEvent >&
CloudEventBatch::events() const {
  // @@protoc_insertion_point(field_list:io.cloudevents.v1.CloudEventBatch.events)
  return _impl_.events_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace cloudevents
}  // namespace io

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cloudevents_2eproto
